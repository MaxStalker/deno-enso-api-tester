/* tslint:disable */
/* eslint-disable */
/**
 * #### Enso API - Find detailed documentation on [docs.enso.finance](https://docs.enso.finance). - To use the API, **you must include your API Key in the Authorization header** (Bearer format). - For testing, Swagger pre-authorizes you using the key: `1e02632d-6feb-4a75-a157-documentation` (1rps). - Get your own API Key at [enso.finance/developers](https://enso.finance/developers).
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type { Network, Price, ProtocolModel } from "../models/index";
import {
  NetworkFromJSON,
  NetworkToJSON,
  PriceFromJSON,
  PriceToJSON,
  ProtocolModelFromJSON,
  ProtocolModelToJSON,
} from "../models/index";

export interface NetworksControllerNetworksRequest {
  name?: any;
  chainId?: any;
}

export interface PositionsControllerFindManyRequest {
  underlyingAddress?: any;
  tokenAddress?: any;
  protocolId?: any;
  projectId?: any;
  protocolSlug?: any;
  page?: any;
  orderBy?: any;
  chainId?: any;
}

export interface PricesControllerGetPriceRequest {
  address: any;
  chainId: any;
}

export interface ProtocolsControllerFindAllRequest {
  slug?: any;
}

export interface TokensControllerTokensRequest {
  protocolSlug?: string;
  underlyingTokens?: Array<string>;
  primaryAddress?: string;
  address?: string;
  chainId?: number;
  type?: TokensControllerTokensTypeEnum;
  page?: number;
}

/** */
export class MetadataApi extends runtime.BaseAPI {
  /**
   * Returns networks supported by the API
   */
  async networksControllerNetworksRaw(
    requestParameters: NetworksControllerNetworksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<Network>>> {
    const queryParameters: any = {};

    if (requestParameters["name"] != null) {
      queryParameters["name"] = requestParameters["name"];
    }

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/networks`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => jsonValue.map(NetworkFromJSON),
    );
  }

  /**
   * Returns networks supported by the API
   */
  async networksControllerNetworks(
    requestParameters: NetworksControllerNetworksRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<Network>> {
    const response = await this.networksControllerNetworksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns all seeded positions
   * @deprecated
   */
  async positionsControllerFindManyRaw(
    requestParameters: PositionsControllerFindManyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters["underlyingAddress"] != null) {
      queryParameters["underlyingAddress"] =
        requestParameters["underlyingAddress"];
    }

    if (requestParameters["tokenAddress"] != null) {
      queryParameters["tokenAddress"] = requestParameters["tokenAddress"];
    }

    if (requestParameters["protocolId"] != null) {
      queryParameters["protocolId"] = requestParameters["protocolId"];
    }

    if (requestParameters["projectId"] != null) {
      queryParameters["projectId"] = requestParameters["projectId"];
    }

    if (requestParameters["protocolSlug"] != null) {
      queryParameters["protocolSlug"] = requestParameters["protocolSlug"];
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }

    if (requestParameters["orderBy"] != null) {
      queryParameters["orderBy"] = requestParameters["orderBy"];
    }

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/positions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Returns all seeded positions
   * @deprecated
   */
  async positionsControllerFindMany(
    requestParameters: PositionsControllerFindManyRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.positionsControllerFindManyRaw(requestParameters, initOverrides);
  }

  /**
   * Returns price for a token
   * @deprecated
   */
  async pricesControllerGetPriceRaw(
    requestParameters: PricesControllerGetPriceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Price>> {
    if (requestParameters["address"] == null) {
      throw new runtime.RequiredError(
        "address",
        'Required parameter "address" was null or undefined when calling pricesControllerGetPrice().',
      );
    }

    if (requestParameters["chainId"] == null) {
      throw new runtime.RequiredError(
        "chainId",
        'Required parameter "chainId" was null or undefined when calling pricesControllerGetPrice().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/prices/{chainId}/{address}`.replace(
        `{${"address"}}`,
        encodeURIComponent(String(requestParameters["address"])),
      ).replace(
        `{${"chainId"}}`,
        encodeURIComponent(String(requestParameters["chainId"])),
      ),
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => PriceFromJSON(jsonValue),
    );
  }

  /**
   * Returns price for a token
   * @deprecated
   */
  async pricesControllerGetPrice(
    requestParameters: PricesControllerGetPriceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Price> {
    const response = await this.pricesControllerGetPriceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns projects and relevant protocols available to use in bundle shortcuts
   */
  async protocolsControllerFindAllRaw(
    requestParameters: ProtocolsControllerFindAllRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<ProtocolModel>>> {
    const queryParameters: any = {};

    if (requestParameters["slug"] != null) {
      queryParameters["slug"] = requestParameters["slug"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/protocols`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => jsonValue.map(ProtocolModelFromJSON),
    );
  }

  /**
   * Returns projects and relevant protocols available to use in bundle shortcuts
   */
  async protocolsControllerFindAll(
    requestParameters: ProtocolsControllerFindAllRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<ProtocolModel>> {
    const response = await this.protocolsControllerFindAllRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns tokens and their details
   */
  async tokensControllerTokensRaw(
    requestParameters: TokensControllerTokensRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters["protocolSlug"] != null) {
      queryParameters["protocolSlug"] = requestParameters["protocolSlug"];
    }

    if (requestParameters["underlyingTokens"] != null) {
      queryParameters["underlyingTokens"] =
        requestParameters["underlyingTokens"];
    }

    if (requestParameters["primaryAddress"] != null) {
      queryParameters["primaryAddress"] = requestParameters["primaryAddress"];
    }

    if (requestParameters["address"] != null) {
      queryParameters["address"] = requestParameters["address"];
    }

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    if (requestParameters["type"] != null) {
      queryParameters["type"] = requestParameters["type"];
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }

    const response = await this.request({
      path: `/api/v1/tokens`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.JSONApiResponse(response);

    // return new runtime.JSONApiResponse(response).value()
  }

  /**
   * Returns tokens and their details
   */
  async tokensControllerTokens(
    requestParameters: TokensControllerTokensRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const out = await this.tokensControllerTokensRaw(
      requestParameters,
      initOverrides,
    );

    return out.value();
  }
}

/**
 * @export
 */
export const TokensControllerTokensTypeEnum = {
  Defi: "defi",
  Base: "base",
} as const;
export type TokensControllerTokensTypeEnum =
  typeof TokensControllerTokensTypeEnum[
    keyof typeof TokensControllerTokensTypeEnum
  ];
