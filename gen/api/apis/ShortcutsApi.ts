/* tslint:disable */
/* eslint-disable */
/**
 * #### Enso API - Find detailed documentation on [docs.enso.finance](https://docs.enso.finance). - To use the API, **you must include your API Key in the Authorization header** (Bearer format). - For testing, Swagger pre-authorizes you using the key: `1e02632d-6feb-4a75-a157-documentation` (1rps). - Get your own API Key at [enso.finance/developers](https://enso.finance/developers).
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  ActionToBundle,
  BundleShortcutTransaction,
  IporShortcutInput,
  IporShortcutTransaction,
  Quote,
  QuoteRouteInputs,
  RouteShortcutTransaction,
  RouteShortcutVariableInputs,
} from "../models/index";
import {
  ActionToBundleFromJSON,
  ActionToBundleToJSON,
  BundleShortcutTransactionFromJSON,
  BundleShortcutTransactionToJSON,
  IporShortcutInputFromJSON,
  IporShortcutInputToJSON,
  IporShortcutTransactionFromJSON,
  IporShortcutTransactionToJSON,
  QuoteFromJSON,
  QuoteRouteInputsFromJSON,
  QuoteRouteInputsToJSON,
  QuoteToJSON,
  RouteShortcutTransactionFromJSON,
  RouteShortcutTransactionToJSON,
  RouteShortcutVariableInputsFromJSON,
  RouteShortcutVariableInputsToJSON,
} from "../models/index";

export interface BundleControllerBundleShortcutTransactionRequest {
  fromAddress: string;
  actionToBundle: Array<ActionToBundle>;
  chainId?: number;
  routingStrategy?:
    BundleControllerBundleShortcutTransactionRoutingStrategyEnum;
}

export interface IporControllerIporShortcutTransactionRequest {
  fromAddress: string;
  iporShortcutInput: IporShortcutInput;
  chainId?: number;
}

export interface QuoteControllerQuoteRequest {
  tokenIn: Array<string>;
  tokenOut: Array<string>;
  amountIn: Array<string>;
  chainId?: number;
  fromAddress?: string;
  routingStrategy?: QuoteControllerQuoteRoutingStrategyEnum;
  fee?: Array<string>;
  feeReceiver?: string;
  disableRFQs?: boolean | null;
  ignoreAggregators?: Array<string> | null;
  ignoreStandards?: Array<string> | null;
}

export interface QuoteControllerQuoteMultipathRequest {
  quoteRouteInputs: QuoteRouteInputs;
}

export interface RouterControllerPostRouteShortcutTransactionRequest {
  routeShortcutVariableInputs: RouteShortcutVariableInputs;
}

export interface RouterControllerRouteShortcutTransactionRequest {
  fromAddress: string;
  amountIn: Array<string>;
  tokenIn: Array<string>;
  tokenOut: Array<string>;
  chainId?: number;
  routingStrategy?: RouterControllerRouteShortcutTransactionRoutingStrategyEnum;
  toEoa?: boolean | null;
  receiver?: string;
  spender?: string;
  amountOut?: Array<string>;
  minAmountOut?: Array<string>;
  slippage?: string;
  fee?: Array<string>;
  feeReceiver?: string;
  disableRFQs?: boolean | null;
  ignoreAggregators?: Array<string> | null;
  ignoreStandards?: Array<string> | null;
}

/** */
export class ShortcutsApi extends runtime.BaseAPI {
  /**
   * Bundle a list of actions into a single tx
   */
  async bundleControllerBundleShortcutTransactionRaw(
    requestParameters: BundleControllerBundleShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<BundleShortcutTransaction>> {
    if (requestParameters["fromAddress"] == null) {
      throw new runtime.RequiredError(
        "fromAddress",
        'Required parameter "fromAddress" was null or undefined when calling bundleControllerBundleShortcutTransaction().',
      );
    }

    if (requestParameters["actionToBundle"] == null) {
      throw new runtime.RequiredError(
        "actionToBundle",
        'Required parameter "actionToBundle" was null or undefined when calling bundleControllerBundleShortcutTransaction().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    if (requestParameters["fromAddress"] != null) {
      queryParameters["fromAddress"] = requestParameters["fromAddress"];
    }

    if (requestParameters["routingStrategy"] != null) {
      queryParameters["routingStrategy"] = requestParameters["routingStrategy"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/shortcuts/bundle`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["actionToBundle"]!.map(ActionToBundleToJSON),
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => BundleShortcutTransactionFromJSON(jsonValue),
    );
  }

  /**
   * Bundle a list of actions into a single tx
   */
  async bundleControllerBundleShortcutTransaction(
    requestParameters: BundleControllerBundleShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<BundleShortcutTransaction> {
    const response = await this.bundleControllerBundleShortcutTransactionRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get transaction for IPOR shortcut
   */
  async iporControllerIporShortcutTransactionRaw(
    requestParameters: IporControllerIporShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<IporShortcutTransaction>> {
    if (requestParameters["fromAddress"] == null) {
      throw new runtime.RequiredError(
        "fromAddress",
        'Required parameter "fromAddress" was null or undefined when calling iporControllerIporShortcutTransaction().',
      );
    }

    if (requestParameters["iporShortcutInput"] == null) {
      throw new runtime.RequiredError(
        "iporShortcutInput",
        'Required parameter "iporShortcutInput" was null or undefined when calling iporControllerIporShortcutTransaction().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    if (requestParameters["fromAddress"] != null) {
      queryParameters["fromAddress"] = requestParameters["fromAddress"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/shortcuts/static/ipor`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: IporShortcutInputToJSON(requestParameters["iporShortcutInput"]),
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => IporShortcutTransactionFromJSON(jsonValue),
    );
  }

  /**
   * Get transaction for IPOR shortcut
   */
  async iporControllerIporShortcutTransaction(
    requestParameters: IporControllerIporShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<IporShortcutTransaction> {
    const response = await this.iporControllerIporShortcutTransactionRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Quote from a token to another
   */
  async quoteControllerQuoteRaw(
    requestParameters: QuoteControllerQuoteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["tokenIn"] == null) {
      throw new runtime.RequiredError(
        "tokenIn",
        'Required parameter "tokenIn" was null or undefined when calling quoteControllerQuote().',
      );
    }

    if (requestParameters["tokenOut"] == null) {
      throw new runtime.RequiredError(
        "tokenOut",
        'Required parameter "tokenOut" was null or undefined when calling quoteControllerQuote().',
      );
    }

    if (requestParameters["amountIn"] == null) {
      throw new runtime.RequiredError(
        "amountIn",
        'Required parameter "amountIn" was null or undefined when calling quoteControllerQuote().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    if (requestParameters["fromAddress"] != null) {
      queryParameters["fromAddress"] = requestParameters["fromAddress"];
    }

    if (requestParameters["routingStrategy"] != null) {
      queryParameters["routingStrategy"] = requestParameters["routingStrategy"];
    }

    if (requestParameters["tokenIn"] != null) {
      queryParameters["tokenIn"] = requestParameters["tokenIn"];
    }

    if (requestParameters["tokenOut"] != null) {
      queryParameters["tokenOut"] = requestParameters["tokenOut"];
    }

    if (requestParameters["amountIn"] != null) {
      queryParameters["amountIn"] = requestParameters["amountIn"];
    }

    if (requestParameters["fee"] != null) {
      queryParameters["fee"] = requestParameters["fee"];
    }

    if (requestParameters["feeReceiver"] != null) {
      queryParameters["feeReceiver"] = requestParameters["feeReceiver"];
    }

    if (requestParameters["disableRFQs"] != null) {
      queryParameters["disableRFQs"] = requestParameters["disableRFQs"];
    }

    if (requestParameters["ignoreAggregators"] != null) {
      queryParameters["ignoreAggregators"] =
        requestParameters["ignoreAggregators"];
    }

    if (requestParameters["ignoreStandards"] != null) {
      queryParameters["ignoreStandards"] = requestParameters["ignoreStandards"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/shortcuts/quote`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Quote from a token to another
   */
  async quoteControllerQuote(
    requestParameters: QuoteControllerQuoteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const out = await this.quoteControllerQuoteRaw(
      requestParameters,
      initOverrides,
    );

    return out.value();
  }

  /**
   * Simulate a route
   */
  async quoteControllerQuoteMultipathRaw(
    requestParameters: QuoteControllerQuoteMultipathRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Quote>> {
    if (requestParameters["quoteRouteInputs"] == null) {
      throw new runtime.RequiredError(
        "quoteRouteInputs",
        'Required parameter "quoteRouteInputs" was null or undefined when calling quoteControllerQuoteMultipath().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/shortcuts/quote`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: QuoteRouteInputsToJSON(requestParameters["quoteRouteInputs"]),
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => QuoteFromJSON(jsonValue),
    );
  }

  /**
   * Simulate a route
   */
  async quoteControllerQuoteMultipath(
    requestParameters: QuoteControllerQuoteMultipathRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Quote> {
    const response = await this.quoteControllerQuoteMultipathRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Best route from a token to another
   */
  async routerControllerPostRouteShortcutTransactionRaw(
    requestParameters: RouterControllerPostRouteShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<RouteShortcutTransaction>> {
    if (requestParameters["routeShortcutVariableInputs"] == null) {
      throw new runtime.RequiredError(
        "routeShortcutVariableInputs",
        'Required parameter "routeShortcutVariableInputs" was null or undefined when calling routerControllerPostRouteShortcutTransaction().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/shortcuts/route`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RouteShortcutVariableInputsToJSON(
        requestParameters["routeShortcutVariableInputs"],
      ),
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => RouteShortcutTransactionFromJSON(jsonValue),
    );
  }

  /**
   * Best route from a token to another
   */
  async routerControllerPostRouteShortcutTransaction(
    requestParameters: RouterControllerPostRouteShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<RouteShortcutTransaction> {
    const response = await this.routerControllerPostRouteShortcutTransactionRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Best route from a token to another
   */
  async routerControllerRouteShortcutTransactionRaw(
    requestParameters: RouterControllerRouteShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<RouteShortcutTransaction>> {
    if (requestParameters["fromAddress"] == null) {
      throw new runtime.RequiredError(
        "fromAddress",
        'Required parameter "fromAddress" was null or undefined when calling routerControllerRouteShortcutTransaction().',
      );
    }

    if (requestParameters["amountIn"] == null) {
      throw new runtime.RequiredError(
        "amountIn",
        'Required parameter "amountIn" was null or undefined when calling routerControllerRouteShortcutTransaction().',
      );
    }

    if (requestParameters["tokenIn"] == null) {
      throw new runtime.RequiredError(
        "tokenIn",
        'Required parameter "tokenIn" was null or undefined when calling routerControllerRouteShortcutTransaction().',
      );
    }

    if (requestParameters["tokenOut"] == null) {
      throw new runtime.RequiredError(
        "tokenOut",
        'Required parameter "tokenOut" was null or undefined when calling routerControllerRouteShortcutTransaction().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["chainId"] != null) {
      queryParameters["chainId"] = requestParameters["chainId"];
    }

    if (requestParameters["fromAddress"] != null) {
      queryParameters["fromAddress"] = requestParameters["fromAddress"];
    }

    if (requestParameters["routingStrategy"] != null) {
      queryParameters["routingStrategy"] = requestParameters["routingStrategy"];
    }

    if (requestParameters["toEoa"] != null) {
      queryParameters["toEoa"] = requestParameters["toEoa"];
    }

    if (requestParameters["receiver"] != null) {
      queryParameters["receiver"] = requestParameters["receiver"];
    }

    if (requestParameters["spender"] != null) {
      queryParameters["spender"] = requestParameters["spender"];
    }

    if (requestParameters["amountIn"] != null) {
      queryParameters["amountIn"] = requestParameters["amountIn"];
    }

    if (requestParameters["amountOut"] != null) {
      queryParameters["amountOut"] = requestParameters["amountOut"];
    }

    if (requestParameters["minAmountOut"] != null) {
      queryParameters["minAmountOut"] = requestParameters["minAmountOut"];
    }

    if (requestParameters["slippage"] != null) {
      queryParameters["slippage"] = requestParameters["slippage"];
    }

    if (requestParameters["fee"] != null) {
      queryParameters["fee"] = requestParameters["fee"];
    }

    if (requestParameters["feeReceiver"] != null) {
      queryParameters["feeReceiver"] = requestParameters["feeReceiver"];
    }

    if (requestParameters["disableRFQs"] != null) {
      queryParameters["disableRFQs"] = requestParameters["disableRFQs"];
    }

    if (requestParameters["ignoreAggregators"] != null) {
      queryParameters["ignoreAggregators"] =
        requestParameters["ignoreAggregators"];
    }

    if (requestParameters["ignoreStandards"] != null) {
      queryParameters["ignoreStandards"] = requestParameters["ignoreStandards"];
    }

    if (requestParameters["tokenIn"] != null) {
      queryParameters["tokenIn"] = requestParameters["tokenIn"];
    }

    if (requestParameters["tokenOut"] != null) {
      queryParameters["tokenOut"] = requestParameters["tokenOut"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearer", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/shortcuts/route`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
    }, initOverrides);

    return new runtime.JSONApiResponse(
      response,
      (jsonValue) => RouteShortcutTransactionFromJSON(jsonValue),
    );
  }

  /**
   * Best route from a token to another
   */
  async routerControllerRouteShortcutTransaction(
    requestParameters: RouterControllerRouteShortcutTransactionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<RouteShortcutTransaction> {
    const response = await this.routerControllerRouteShortcutTransactionRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const BundleControllerBundleShortcutTransactionRoutingStrategyEnum = {
  Ensowallet: "ensowallet",
  Delegate: "delegate",
} as const;
export type BundleControllerBundleShortcutTransactionRoutingStrategyEnum =
  typeof BundleControllerBundleShortcutTransactionRoutingStrategyEnum[
    keyof typeof BundleControllerBundleShortcutTransactionRoutingStrategyEnum
  ];
/**
 * @export
 */
export const QuoteControllerQuoteRoutingStrategyEnum = {
  Ensowallet: "ensowallet",
  Router: "router",
  Delegate: "delegate",
} as const;
export type QuoteControllerQuoteRoutingStrategyEnum =
  typeof QuoteControllerQuoteRoutingStrategyEnum[
    keyof typeof QuoteControllerQuoteRoutingStrategyEnum
  ];
/**
 * @export
 */
export const RouterControllerRouteShortcutTransactionRoutingStrategyEnum = {
  Ensowallet: "ensowallet",
  Router: "router",
  Delegate: "delegate",
} as const;
export type RouterControllerRouteShortcutTransactionRoutingStrategyEnum =
  typeof RouterControllerRouteShortcutTransactionRoutingStrategyEnum[
    keyof typeof RouterControllerRouteShortcutTransactionRoutingStrategyEnum
  ];
